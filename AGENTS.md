# Repository Guidelines

## Project Structure & Module Organization
Root holds the manifest plus the domain-specific docs (`README.md`, `AGENTS.md`, `HANDOFF.md`). The Chrome extension lives under `extension/` with `content/` for injected scripts and helper modules (`content.js` bootstrap, `overlay.js` for tooltip/inline UI, `feedback.js`, `dom.js`, `config.js`), `ui/` for popup/options surfaces, and `background.js` for the service worker that drives auto-scan and now proxies all backend fetches so content scripts never hit HTTP endpoints directly. The Flask API sits in `backend/` (`backend/app.py`, `backend/requirements.txt`) and now writes feedback into `backend/reports.db`; it reuses TLS cert/key files under `~/.finalextension/`. Screenshots and generated artifacts stay out of git via `.gitignore`.

## Build, Test, and Development Commands
Install extension deps with `npm install`; backend deps with `pip install -r backend/requirements.txt` (installs Flask-CORS, pyOpenSSL, transformers, optimum[onnxruntime]; PyTorch is optional for GPU execution). Build via `npm run build`. For iterative work run `npm run dev` and `npx web-ext run --source-dir dist`. Use `./scripts/dev-server.sh` to provision certificates via `mkcert`, create a virtualenv, and launch the backend in a single step. If you need the manual workflow, run:

```bash
mkdir -p ~/.finalextension/mkcert
mkcert -install
mkcert -cert-file ~/.finalextension/mkcert/localhost.pem \
       -key-file ~/.finalextension/mkcert/localhost-key.pem \
       localhost 127.0.0.1 ::1
export SENTINEL_CERT_FILE="$HOME/.finalextension/mkcert/localhost.pem"
export SENTINEL_KEY_FILE="$HOME/.finalextension/mkcert/localhost-key.pem"
python backend/app.py
```

If `SENTINEL_CERT_FILE`/`SENTINEL_KEY_FILE` are set and exist, the server uses them; otherwise it mints SAN-aware self-signed cert/key files in `~/.finalextension/` (covering `localhost`, `127.0.0.1`, `::1`) and serves `https://localhost:5000/predict`. When falling back to the autogenerated cert, import `~/.finalextension/localhost-cert.pem` into Keychain Access and mark it “Always Trust” before testing in Chrome to avoid the “Not Secure” warning. Need to skip TLS? Set `SENTINEL_HTTP_ONLY=1` before `python backend/app.py` to run plain HTTP on `http://localhost:5000`. Manifest host permissions include both HTTPS (primary) and HTTP (fallback for local http pages). Run `npx web-ext lint` before PRs.

## Coding Style & Naming Conventions
Use TypeScript or modern ES modules in the extension with 2-space indentation, single quotes, and kebab-case filenames (`content-router.ts`). Classes stay PascalCase, exported functions camelCase. Backend code follows PEP 8, 4-space indentation, snake_case helpers, and docstrings on Flask routes—keep modules under `backend/`. Run `npm run lint` and keep `manifest.json` keys alphabetized. Maintain popup/options assets in `extension/ui/` and content scripts in `extension/content/`; `popup.js` manages tab injection plus manual text analysis, the scan trigger, sensitivity slider, highlight-style selector, feedback queue/history views, and the auto-scan toggle (which requests host permissions). `background.js` listens for navigation events and injects the scanner when auto-scan is active. The content stack is modular: `content/content.js` orchestrates scanning, `content/feedback.js` handles queueing/history, `content/dom.js` centralises DOM traversal, and `content/overlay.js` renders highlights/tooltips while owning the feedback controls/CSS.

## Testing Guidelines
Use Vitest or Jest for extension units and Playwright for popup/content flows. Name test files `<module>.spec.ts` or `<module>.test.ts` under `tests/`. For the API, add pytest suites in `tests/api/test_predict.py`, covering happy path, validation failures, GPU/CPU fallbacks, `/predict/batch`, and `/report` persistence in `backend/reports.db`. Target ≥80% statement coverage via `npm run test -- --coverage` and `pytest --cov`; note any gaps in the PR. Run manual smoke checks on social feeds to confirm mutation rescans highlight new posts, tooltip buttons behave, the popup status indicator responds to `scan-start`/`scan-progress`/`scan-complete`, user-selected highlight styles render as expected, `/report` accepts feedback, CORS preflights succeed, and HTTPS calls to `https://localhost:5000/predict` work once the cert is trusted (HTTP fallback only for local http pages).
Verify the feedback queue by simulating offline mode, ensuring reports are queued, pending counts reflect storage, and queued entries flush successfully when connectivity returns. When auto-scan is enabled, confirm permissions are granted, new tabs automatically inject the scanner without manual clicks, and turning the toggle off stops further injections.

## Additions & Refinements Snapshot
- Modular content architecture (`dom.js`, `overlay.js`, `feedback.js`, `config.js`) keeps scanning logic, UI, and storage concerns decoupled for easier auditing.
- Popup refinements: manual analyzer, sensitivity slider, highlight-style selector, feedback queue/history panel, live scan status, and auto-scan toggle with permission guardrails.
- Options page mirrors popup controls so examiners can adjust sensitivity/highlight style from either surface.
- Inline blur/redact/highlight UX now dedupes spans, offers a single show/hide toggle per detection, and surfaces `Not hate?` / `Flag` buttons tied to `/report`.
- Feedback manager persists to SQLite (`backend/reports.db`) plus `chrome.storage.local`, with retry/backoff, offline queueing, and pending-count telemetry.
- Background service worker proxies `/predict`/`/predict/batch`, enabling HTTP fallbacks and avoiding mixed-content errors on HTTPS pages.
- Auto-scan orchestrator injects the scanner on navigation/activation and honors popup toggles, making demos faster.
- Auto-scan reliability improvements: background fetch retries, offline detection, and injection failures now raise clear popup notices for examiners.
- Feedback UX polish: inline buttons signal sent/queued/error states, popup history includes relative timestamps, and entries can be dismissed to keep demo logs tidy.
- Telemetry/debug panel surfaces auto-scan state, last fetch/scan summaries, and recent errors directly in the popup for examiners.
- Jest unit tests cover `extension/content/dom.js`; run via `npm test` after `npm install` to validate helpers.
- TLS tooling: SAN-enabled self-signed certs, mkcert helper scripts, and `SENTINEL_HTTP_ONLY=1` escape hatch for quick HTTP testing.
- Backend hardening: dependency guards with actionable messages, CORS-friendly OPTIONS handling, batch endpoint sanity checks, and `/report` validation.
- Docs + manifest kept in sync (host permissions, resource lists) so examiners can review capabilities quickly.
- Convenience scripts: `scripts/dev-http.sh` runs the backend in HTTP-only mode for quick demos, and `scripts/package-extension.sh` produces `dist/sentinel-extension.zip` for drag-and-drop loading in Chromium browsers.

## Commit & Pull Request Guidelines
History remains clean—adhere to Conventional Commits (`feat:`, `fix:`, `chore:`) for traceability. Each PR must include: linked issue, summary of extension and API changes, verification steps (`npm run build`, `npx web-ext lint`, `python backend/app.py`, relevant tests), and screenshots or gifs for UI updates. Confirm host permission changes (e.g., `http://localhost:5000/*`) in the PR description. Request review only after lint suites and automated tests pass.

Refer to `CONTRIBUTING.md` for the full workflow and to `.github/ISSUE_TEMPLATE/` for required issue formats. All contributors must follow the project `CODE_OF_CONDUCT.md`.
