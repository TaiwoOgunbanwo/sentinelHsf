# Sentinel Hate Speech Detector

Sentinel is a Chrome manifest v3 extension paired with a secure Flask API that classifies in-page text for hate speech using a DeBERTa ONNX model. It was created as part of a dissertation project and focuses on fast highlighting, human review controls, and feedback capture.

## Architecture & Layout

```
.
├── backend/                   # Flask API + SQLite feedback store
│   ├── app.py
│   └── requirements.txt
├── extension/
│   ├── content/               # content scripts & modules
│   │   ├── content.js         # bootstrap (imports helpers)
│   │   ├── feedback.js        # feedback queue/history manager
│   │   ├── dom.js             # DOM helpers (sentences, highlights, signatures)
│   │   └── overlay.js         # tooltip + inline control renderer
│   ├── background.js          # service worker (auto-scan orchestration)
│   ├── config.js              # shared constants & API configuration
│   └── ui/                    # popup + options surfaces
│       ├── options.html
│       ├── options.js
│       ├── popup.html
│       └── popup.js
├── manifest.json              # Chrome MV3 manifest
├── AGENTS.md                  # contributor playbook
├── HANDOFF.md                 # context for future maintainers
└── README.md
```

- **Chrome extension** (`extension/`):
  - `content/content.js` bootstraps the scanner, wiring in helper modules and coordinating fetches.
  - `content/overlay.js` renders highlight wrappers, tooltips, and inline blur/redact controls while dispatching feedback actions.
  - `content/feedback.js` manages offline queueing, retries, and history logging.
  - `content/dom.js` owns DOM traversal, signature building, sentence splitting, and highlight range utilities.
  - `ui/popup.*` powers the action popup (manual analysis, scan trigger, sensitivity slider, highlight-style selector, feedback queue/history, auto-scan toggle).
  - `background.js` listens for navigation events, automatically injects the scanner when auto-scan is enabled, and proxies all backend fetches so the content script never triggers mixed-content blocks.
  - `ui/options.*` persists highlight style and threshold settings.
  - `config.js` centralises runtime constants (API bases, style options, storage keys, default thresholds) shared across modules.
- **Flask backend** (`backend/app.py`):
  - Loads `TaiwoOgun/deberta-v3-hate-speech-onnx` via `optimum.onnxruntime`.
  - Exposes `/predict`, `/predict/batch`, and `/report`.
  - Persists reviewer feedback to `backend/reports.db` (SQLite) and serves HTTPS using a self-signed cert (generated with `pyOpenSSL`).

## Stack

| Layer | Dependencies |
| --- | --- |
| Extension | Chrome MV3, Node/NPM for packaging (scripts TBD) |
| Backend | Python 3.10+, `flask`, `flask-cors`, `torch` (optional GPU), `transformers`, `onnx`, `optimum[onnxruntime]`, `pyOpenSSL`, `sqlite3` |
| Model | Hugging Face `TaiwoOgun/deberta-v3-hate-speech-onnx` (ONNX) |

See `backend/requirements.txt` for the exact Python packages (currently unpinned).

## Running Locally

1. **Backend**
   ```bash
   cd backend
   pip install -r requirements.txt

   # Optional: point to mkcert-generated certs so Chrome automatically trusts HTTPS
   # export SENTINEL_CERT_FILE="$HOME/.finalextension/mkcert/localhost.pem"
   # export SENTINEL_KEY_FILE="$HOME/.finalextension/mkcert/localhost-key.pem"

   python app.py
   ```
   - Generates `backend/reports.db` and self-signed certs under `~/.finalextension/`.
   - Serves `https://localhost:5000/predict`; accept the certificate in Chrome the first time you visit.
   - **Preferred**: install [`mkcert`](https://github.com/FiloSottile/mkcert), run `mkcert -install`, then `mkdir -p ~/.finalextension/mkcert` followed by `mkcert -cert-file ~/.finalextension/mkcert/localhost.pem -key-file ~/.finalextension/mkcert/localhost-key.pem localhost 127.0.0.1 ::1`. Export `SENTINEL_CERT_FILE`/`SENTINEL_KEY_FILE` before launching `python app.py` so Chrome trusts the cert automatically.
   - **Fallback**: if you rely on the autogenerated self-signed cert (SAN entries for `localhost`, `127.0.0.1`, and `::1`), open `~/.finalextension/localhost-cert.pem` in Keychain Access, set “When using this certificate” to “Always Trust”, and restart Chrome. For quick HTTP-only debugging you can run `SENTINEL_HTTP_ONLY=1 python app.py`, but HTTPS is required when scanning HTTPS sites like Twitter.

2. **Extension**
   - `npm install` (future build scripts TBD).
   - Load the repository root as an unpacked extension in `chrome://extensions`.
  - Popup slider controls sensitivity (`chrome.storage.sync`), radio buttons switch highlight style, scan button triggers analysis, and the auto-scan toggle requests host permissions the first time you enable it.
  - Configure the auto-scan allow list from the options page—auto-scan only injects on domains you list (manual scans still work everywhere).
  - For a zero-click install, build a packaged zip (coming soon) or load the `extension/` directory directly during development.

3. **Feedback**
   - Inline “Not hate?” / “Flag” controls POST to `/report`, disable during submission, queue failed attempts for retry, and remove highlights when dismissals succeed.
   - The popup shows pending feedback count plus a recent history pulled from `chrome.storage.local`.

## Tests

Install dev dependencies and run the Jest suite:

```bash
npm install
npm test
```

The current tests cover `extension/content/dom.js` helpers (sentence splitting, highlight wrapping, signature generation). Add new specs alongside `tests/dom.test.js` as the codebase evolves.

## Packaging the Extension

Generate a ready-to-load ZIP (for `chrome://extensions`) with:

```bash
./scripts/package-extension.sh
```

The archive is written to `dist/sentinel-extension.zip`.

## Additions & Refinements

- `/predict`, `/predict/batch`, and `/report` endpoints backed by a persisted SQLite DB (`backend/reports.db`) so examiner feedback survives restarts.
- Background service worker proxies all API calls, combining HTTPS + HTTP bases and eliminating mixed-content failures on locked-down sites.
- Config-driven content architecture: `content/dom.js`, `content/feedback.js`, `content/overlay.js`, and `extension/config.js` isolate DOM, queueing, UI, and shared constants.
- Inline blur/redact/highlight wrappers with deduped spans, show/hide toggles, and feedback buttons that hook directly into `/report`.
- Highlight stability pass: grouped duplicate wrappers by snippet, enforce a single show/hide control per detection, and ensure blur/redact toggles flip all fragments simultaneously for cleaner social-feed demos.
- Auto-scan reliability: background fetches retry with backoff, offline/failed injections surface to the popup, and manual scans share the improved status messaging for examiners.
- Auto-scan allow list: users can scope automatic injections to a curated list of domains while manual scans remain unrestricted for spot checks.
- Auto-scan toggle now signals active tabs to halt continuous scanning immediately, so turning it off pauses observers without forcing a page reload.
- Auto-scan UI refinement: when background scanning is active the manual `Scan This Page` control disables and re-labels itself so examiners instantly see that automatic mode is handling updates.
- Local-only security posture: removed unused API key plumbing so the extension assumes the backend runs on trusted localhost TLS without shared secrets.
- Feedback UX upgrades: inline controls display sent/queued/error states, timestamps bubble into the popup history, and examiners can now dismiss feedback entries when they no longer need the context.
- Plain-language status line: the popup now summarises auto-scan state and the latest scan outcome in a single human-friendly message, keeping debug details out of sight for examiners.
- Activity & Status panel: status messaging now lives alongside the feedback badge and history, so examiners see pending items and latest scan results in one place.
- Popup modules: status, settings, telemetry, analyzer, and feedback history now live in dedicated files, keeping `popup.js` focused on orchestration and trimming its footprint.
- Popup upgrades: manual text analyzer, sensitivity slider, highlight-style radio buttons, feedback history feed, pending-queue badge, auto-scan toggle, and live scan-status indicator.
- Options page parity with popup (confidence slider + highlight-style radios) plus `chrome.storage.sync` persistence.
- Auto-scan service worker that requests host permissions, injects the scanner on navigation/activation, and respects the popup toggle.
- Feedback manager supports offline queueing, retry/backoff, and history capped at 50 entries stored in `chrome.storage.local`.
- Background automation scripts previously provided in `scripts/` are now excluded from the repository; follow the manual backend steps above to provision certs and launch the API.
- TLS hardening: SAN-enabled self-signed certs (`localhost`, `127.0.0.1`, `::1`) and mkcert-aware paths so Chrome can trust the backend quickly.
- Manifest + host permissions tightened (localhost by default, optional `<all_urls>` when users enable auto-scan) and all injected assets declared via `web_accessible_resources`.
- Documentation refresh (README/AGENTS/HANDOFF) outlining install steps, cert workflows, feedback UX, and examiner-focused guidance.

## Limitations & Next Steps

- Auto-detection is manual (requires clicking “Scan This Page”).
- Feedback path is wired; consider retry UI/backoff for repeated failures.
- No automated tests yet—manual verification recommended after each change.
- Background service worker pending for shared state, telemetry, and eventual automatic scanning.

---

- See [CONTRIBUTING.md](CONTRIBUTING.md) for development workflow and commit conventions.
- See [CODE_OF_CONDUCT.md](CODE_OF_CONDUCT.md) for expected behavior.
