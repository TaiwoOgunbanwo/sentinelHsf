# Sentinel Hate Speech Detector

Sentinel is a Chrome manifest v3 extension paired with a secure Flask API that classifies in-page text for hate speech using a DeBERTa ONNX model. It was created as part of a dissertation project and focuses on fast highlighting, human review controls, and feedback capture.

## Architecture & Layout

```
.
├── backend/                   # Flask API + SQLite feedback store
│   ├── app.py
│   └── requirements.txt
├── extension/
│   ├── content/               # content scripts & modules
│   │   ├── content.js         # bootstrap (imports helpers)
│   │   ├── feedback.js        # feedback queue/history manager
│   │   ├── dom.js             # DOM helpers (sentences, highlights, signatures)
│   │   └── overlay.js         # tooltip + inline control renderer
│   ├── background.js          # service worker (auto-scan orchestration)
│   ├── config.js              # shared constants & API configuration
│   └── ui/                    # popup + options surfaces
│       ├── options.html
│       ├── options.js
│       ├── popup.html
│       └── popup.js
├── manifest.json              # Chrome MV3 manifest
├── AGENTS.md                  # contributor playbook
├── HANDOFF.md                 # context for future maintainers
└── README.md
```

- **Chrome extension** (`extension/`):
  - `content/content.js` bootstraps the scanner, wiring in helper modules and coordinating fetches.
  - `content/overlay.js` renders highlight wrappers, tooltips, and inline blur/redact controls while dispatching feedback actions.
  - `content/feedback.js` manages offline queueing, retries, and history logging.
  - `content/dom.js` owns DOM traversal, signature building, sentence splitting, and highlight range utilities.
  - `ui/popup.*` powers the action popup (manual analysis, scan trigger, sensitivity slider, highlight-style selector, feedback queue/history, auto-scan toggle).
  - `background.js` listens for navigation events, automatically injects the scanner when auto-scan is enabled, and proxies all backend fetches so the content script never triggers mixed-content blocks.
  - `ui/options.*` persists highlight style and threshold settings.
  - `config.js` centralises runtime constants (API bases, style options, storage keys, default thresholds/API key placeholder).
- **Flask backend** (`backend/app.py`):
  - Loads `TaiwoOgun/deberta-v3-hate-speech-onnx` via `optimum.onnxruntime`.
  - Exposes `/predict`, `/predict/batch`, and `/report`.
  - Persists reviewer feedback to `backend/reports.db` (SQLite) and serves HTTPS using a self-signed cert (generated with `pyOpenSSL`).

## Stack

| Layer | Dependencies |
| --- | --- |
| Extension | Chrome MV3, Node/NPM for packaging (scripts TBD) |
| Backend | Python 3.10+, `flask`, `flask-cors`, `torch` (optional GPU), `transformers`, `onnx`, `optimum[onnxruntime]`, `pyOpenSSL`, `sqlite3` |
| Model | Hugging Face `TaiwoOgun/deberta-v3-hate-speech-onnx` (ONNX) |

See `backend/requirements.txt` for the exact Python packages (currently unpinned).

## Running Locally

1. **Backend**
   ```bash
   # HTTPS (trusted via mkcert)
   ./scripts/dev-server.sh
   ```
   - Creates a Python virtualenv (`.venv/`), installs dependencies, provisions trusted HTTPS certs via `mkcert`, and starts the Flask server on `https://localhost:5000`.
   - Run this once per session; it will reuse the existing certificates and virtualenv on subsequent calls.

   **Manual alternative**
   ```bash
   cd backend
   # Optional: point to mkcert-generated certs
   # export SENTINEL_CERT_FILE="$HOME/.finalextension/mkcert/localhost.pem"
   # export SENTINEL_KEY_FILE="$HOME/.finalextension/mkcert/localhost-key.pem"
   pip install -r requirements.txt
   python app.py
   ```
   - Generates `backend/reports.db` and self-signed certs under `~/.finalextension/`.
   - Serves `https://localhost:5000/predict` (accept the cert in Chrome). HTTP is available as a fallback for non-HTTPS pages.
   - **Preferred**: install [`mkcert`](https://github.com/FiloSottile/mkcert), run `mkcert -install` once, then `mkdir -p ~/.finalextension/mkcert` followed by `mkcert -cert-file ~/.finalextension/mkcert/localhost.pem -key-file ~/.finalextension/mkcert/localhost-key.pem localhost 127.0.0.1 ::1`. Export `SENTINEL_CERT_FILE`/`SENTINEL_KEY_FILE` (see above) before launching the server so Chrome trusts the cert automatically.
   - **Fallback**: if you use the autogenerated self-signed cert (now issued with SAN entries for `localhost`, `127.0.0.1`, and `::1`), open `~/.finalextension/localhost-cert.pem` in Keychain Access, set “When using this certificate” to “Always Trust”, and restart Chrome. You can disable TLS entirely for local debugging via:

     ```bash
     ./scripts/dev-http.sh            # serves plain HTTP on http://localhost:5000
     ```

     or `SENTINEL_HTTP_ONLY=1 python app.py` if you are inside `backend/`.

2. **Extension**
   - `npm install` (future build scripts TBD).
   - Load the repository root as an unpacked extension in `chrome://extensions`.
   - Popup slider controls sensitivity (`chrome.storage.sync`), radio buttons switch highlight style, scan button triggers analysis, and the auto-scan toggle requests host permissions the first time you enable it.
   - For a zero-click install, build a packaged zip (coming soon) or load the `extension/` directory directly during development.

3. **Feedback**
   - Inline “Not hate?” / “Flag” controls POST to `/report`, disable during submission, queue failed attempts for retry, and remove highlights when dismissals succeed.
   - The popup shows pending feedback count plus a recent history pulled from `chrome.storage.local`.

## Packaging the Extension

Generate a ready-to-load ZIP (for `chrome://extensions`) with:

```bash
./scripts/package-extension.sh
```

The archive is written to `dist/sentinel-extension.zip`.

## Additions & Refinements

- `/predict`, `/predict/batch`, and `/report` endpoints backed by a persisted SQLite DB (`backend/reports.db`) so examiner feedback survives restarts.
- Background service worker proxies all API calls, combining HTTPS + HTTP bases and eliminating mixed-content failures on locked-down sites.
- Config-driven content architecture: `content/dom.js`, `content/feedback.js`, `content/overlay.js`, and `extension/config.js` isolate DOM, queueing, UI, and shared constants.
- Inline blur/redact/highlight wrappers with deduped spans, show/hide toggles, and feedback buttons that hook directly into `/report`.
- Highlight stability pass: grouped duplicate wrappers by snippet, enforce a single show/hide control per detection, and ensure blur/redact toggles flip all fragments simultaneously for cleaner social-feed demos.
- Auto-scan reliability: background fetches retry with backoff, offline/failed injections surface to the popup, and manual scans share the improved status messaging for examiners.
- Feedback UX upgrades: inline controls display sent/queued/error states, timestamps bubble into the popup history, and examiners can now dismiss feedback entries when they no longer need the context.
- Telemetry/debug panel: popup now shows auto-scan state, last fetch/scan summaries, and recent errors, with a refresh button driven by background telemetry broadcasts.
- Popup upgrades: manual text analyzer, sensitivity slider, highlight-style radio buttons, feedback history feed, pending-queue badge, auto-scan toggle, and live scan-status indicator.
- Options page parity with popup (confidence slider + highlight-style radios) plus `chrome.storage.sync` persistence.
- Auto-scan service worker that requests host permissions, injects the scanner on navigation/activation, and respects the popup toggle.
- Feedback manager supports offline queueing, retry/backoff, and history capped at 50 entries stored in `chrome.storage.local`.
- Background scripts and scripts (`dev-server.sh`, `setup-cert.sh`) provision mkcert certificates, virtualenvs, and HTTPS automatically; fallback env var `SENTINEL_HTTP_ONLY=1` exposes plain HTTP for frictionless demos.
- TLS hardening: SAN-enabled self-signed certs (`localhost`, `127.0.0.1`, `::1`) and mkcert-aware paths so Chrome can trust the backend quickly.
- Manifest + host permissions tightened (localhost by default, optional `<all_urls>` when users enable auto-scan) and all injected assets declared via `web_accessible_resources`.
- Documentation refresh (README/AGENTS/HANDOFF) outlining install steps, cert workflows, feedback UX, and examiner-focused guidance.

## Limitations & Next Steps

- Auto-detection is manual (requires clicking “Scan This Page”).
- Feedback path is wired; consider retry UI/backoff for repeated failures.
- No automated tests yet—manual verification recommended after each change.
- Background service worker pending for shared state, telemetry, and eventual automatic scanning.

---

- See [CONTRIBUTING.md](CONTRIBUTING.md) for development workflow and commit conventions.
- See [CODE_OF_CONDUCT.md](CODE_OF_CONDUCT.md) for expected behavior.
